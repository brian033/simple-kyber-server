import { ChainId, Currency, CurrencyAmount, Percent, Price, TradeType } from '@dynamic-amm/sdk';
import { DexConfig } from './config/dexes';
interface AggregationComparer {
    inputAmount: CurrencyAmount;
    outputAmount: CurrencyAmount;
    amountInUsd: string;
    amountOutUsd: string;
    receivedUsd: string;
    comparedDex: DexConfig;
    tradeSaved?: {
        percent?: number;
        usd?: string;
    };
}
declare type GasPrice = {
    fast: string;
    standard: string;
    low: string;
    default: string;
};
declare type ExchangeConfig = {
    id: number;
    type: number;
} & DexConfig;
export declare const getExchangeConfig: (exchange: string, chainId: ChainId) => ExchangeConfig;
export declare function isEncodeUniswapCallback(chainId: ChainId): (swap: any) => boolean;
export declare function encodeSwapExecutor(swaps: any[][], chainId: ChainId): {
    data: string;
    dexOption: number;
}[][];
export declare function encodeFeeConfig({ feeReceiver, isInBps, feeAmount, }: {
    feeReceiver: string;
    isInBps: boolean;
    feeAmount: string;
}): string;
export declare function encodeSimpleModeData(data: {
    firstPools: string[];
    firstSwapAmounts: string[];
    swapSequences: {
        data: string;
        dexOption: any;
    }[][];
    deadline: string;
    destTokenFeeData: string;
}): string;
/**
 */
export declare class Aggregator {
    /**
     * The type of the trade, either exact in or exact out.
     */
    readonly tradeType: TradeType;
    /**
     * The input amount for the trade assuming no slippage.
     */
    readonly inputAmount: CurrencyAmount;
    /**
     * The output amount for the trade assuming no slippage.
     */
    readonly outputAmount: CurrencyAmount;
    /**
     */
    readonly swaps: any[][];
    /**
     */
    readonly tokens: any;
    /**
     * The price expressed in terms of output amount/input amount.
     */
    readonly executionPrice: Price;
    readonly amountInUsd: string;
    readonly amountOutUsd: string;
    readonly receivedUsd: string;
    readonly gasUsd: number;
    readonly priceImpact: number;
    constructor(inputAmount: CurrencyAmount, outputAmount: CurrencyAmount, amountInUsd: string, amountOutUsd: string, receivedUsd: string, swaps: any[][], tokens: any, tradeType: TradeType, gasUsd: number, priceImpact: number);
    /**
     * Get the minimum amount that must be received from this trade for the given slippage tolerance
     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade
     */
    minimumAmountOut(slippageTolerance: Percent): CurrencyAmount;
    /**
     * Get the maximum amount in that can be spent via this trade for the given slippage tolerance
     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade
     */
    maximumAmountIn(slippageTolerance: Percent): CurrencyAmount;
    /**
     * @param baseURL
     * @param currencyAmountIn exact amount of input currency to spend
     * @param currencyOut the desired currency out
     * @param saveGas
     */
    static bestTradeExactIn(baseURL: string, currencyAmountIn: CurrencyAmount, currencyOut: Currency, saveGas?: boolean, dexes?: string, gasPrice?: GasPrice): Promise<Aggregator | null>;
    /**
     * @param baseURL
     * @param currencyAmountIn exact amount of input currency to spend
     * @param currencyOut the desired currency out
     */
    static compareDex(baseURL: string, currencyAmountIn: CurrencyAmount, currencyOut: Currency): Promise<AggregationComparer | null>;
}
export {};
